<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>tcpdump</title>
    <url>/2020/05/01/tcpdump/</url>
    <content><![CDATA[<p>如果你抓过 TCP 的包，你一定听说过图形化界面软件 wireshark，tcpdump 则是一个命令行的网络流量分析工具，功能非常强大。尤其是做后台开发的同学要在服务器上定位一些黑盒的应用，tcpdump 是唯一的选择。这篇文章会重点介绍基本使用、过滤条件、保存文件几个方面。</p>
<a id="more"></a>

<h2 id="TCPDump-基础"><a href="#TCPDump-基础" class="headerlink" title="TCPDump 基础"></a>TCPDump 基础</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any</span><br></pre></td></tr></table></figure>
<p>-i表示指定哪一个网卡，any 表示任意。有哪些网卡可以用 ifconfig 来查看，在我的虚拟机上，ifconfig 输出结果如下<br>如果只想查看 eth0 网卡经过的数据包，就可以使用tcpdump -i eth0来指定。</p>
<h3 id="过滤主机：host-选项"><a href="#过滤主机：host-选项" class="headerlink" title="过滤主机：host 选项"></a>过滤主机：host 选项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any host 10.211.55.2</span><br></pre></td></tr></table></figure>
<h3 id="过滤源地址、目标地址：src、dst"><a href="#过滤源地址、目标地址：src、dst" class="headerlink" title="过滤源地址、目标地址：src、dst"></a>过滤源地址、目标地址：src、dst</h3><p>如果只想抓取主机 10.211.55.10 发出的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10</span><br></pre></td></tr></table></figure>
<p>如果只想抓取主机 10.211.55.10 收到的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any dst 10.211.55.1</span><br></pre></td></tr></table></figure>
<h3 id="过滤端口：port-选项"><a href="#过滤端口：port-选项" class="headerlink" title="过滤端口：port 选项"></a>过滤端口：port 选项</h3><p>抓取某端口的数据包：port 选项比如查看 80 端通信的数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any port 80</span><br></pre></td></tr></table></figure>
<p>如果只想抓取 80 端口收到的包，可以加上 dst</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any dst port 80</span><br></pre></td></tr></table></figure>
<h3 id="过滤指定端口范围内的流量"><a href="#过滤指定端口范围内的流量" class="headerlink" title="过滤指定端口范围内的流量"></a>过滤指定端口范围内的流量</h3><p>比如抓取 21 到 23 区间所有端口的流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump portrange 21-23</span><br></pre></td></tr></table></figure>
<h3 id="禁用主机与端口解析：-n-与-nn-选项"><a href="#禁用主机与端口解析：-n-与-nn-选项" class="headerlink" title="禁用主机与端口解析：-n 与 -nn 选项"></a>禁用主机与端口解析：-n 与 -nn 选项</h3><p>如果不加-n选项，tcpdump 会显示主机名，比如下面的test.ya.local和c2.shared</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">09:04:56.821206 IP test.ya.local.59915 &gt; c2.shared.ssh: Flags [P.], seq 397:433, ack 579276, win 2048, options [nop,nop,TS val 1200089877 ecr 435612355], length 36</span><br></pre></td></tr></table></figure>
<p>加上-n选项以后，可以看到主机名都已经被替换成了 ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any  -n</span><br><span class="line">10:02:13.705656 IP 10.211.55.2.59915 &gt; 10.211.55.10.ssh: Flags [P.], seq 829:865, ack 1228756, win 2048, options [nop,nop,TS val 1203228910 ecr 439049239], length 36</span><br></pre></td></tr></table></figure>
<p>但是常用端口还是会被转换成协议名，比如 ssh 协议的 22 端口。如果不想 tcpdump 做转换，可以加上 -nn，这样就不会解析端口了，输出中的 ssh 变为了 22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any  -nn</span><br><span class="line"></span><br><span class="line">10:07:37.598725 IP 10.211.55.2.59915 &gt; 10.211.55.10.22: Flags [P.], seq 685:721, ack 1006224, win 2048, options [nop,nop,TS val 1203524536 ecr 439373132], length 36</span><br></pre></td></tr></table></figure>

<h3 id="过滤协议"><a href="#过滤协议" class="headerlink" title="过滤协议"></a>过滤协议</h3><p>只想查看 udp 协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any -nn udp</span><br></pre></td></tr></table></figure>

<h3 id="用-ASCII-格式查看包体内容：-A-选项"><a href="#用-ASCII-格式查看包体内容：-A-选项" class="headerlink" title="用 ASCII 格式查看包体内容：-A 选项"></a>用 ASCII 格式查看包体内容：-A 选项</h3><p>使用 -A 可以用 ASCII 打印报文内容，比如常用的 HTTP 协议传输 json 、html 文件等都可以用这个选项</p>
<h3 id="与-A-对应的还有一个-X-命令，用来同时用-HEX-和-ASCII-显示报文内容。"><a href="#与-A-对应的还有一个-X-命令，用来同时用-HEX-和-ASCII-显示报文内容。" class="headerlink" title="与 -A 对应的还有一个 -X 命令，用来同时用 HEX 和 ASCII 显示报文内容。"></a>与 -A 对应的还有一个 -X 命令，用来同时用 HEX 和 ASCII 显示报文内容。</h3><h3 id="限制包大小：-s-选项"><a href="#限制包大小：-s-选项" class="headerlink" title="限制包大小：-s 选项"></a>限制包大小：-s 选项</h3><p>当包体很大，可以用 -s 选项截取部分报文内容，一般都跟 -A 一起使用。查看每个包体前 500 字节可以用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any -nn port 80 -A -s 500</span><br></pre></td></tr></table></figure>
<p>如果想显示包体所有内容，可以加上-s 0</p>
<h3 id="只抓取-5-个报文：-c-选项"><a href="#只抓取-5-个报文：-c-选项" class="headerlink" title="只抓取 5 个报文： -c 选项"></a>只抓取 5 个报文： -c 选项</h3><p>使用 -c number命令可以抓取 number 个报文后退出。在网络包交互非常频繁的服务器上抓包比较有用，可能运维人员只想抓取 1000 个包来分析一些网络问题，就比较有用了。<br>sudo tcpdump -i any -nn port 80  -c 5</p>
<h3 id="数据报文输出到文件：-w-选项"><a href="#数据报文输出到文件：-w-选项" class="headerlink" title="数据报文输出到文件：-w 选项"></a>数据报文输出到文件：-w 选项</h3><p>-w 选项用来把数据报文输出到文件，比如下面的命令就是把所有 80 端口的数据输出到文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any port 80 -w test.pcap</span><br></pre></td></tr></table></figure>
<p>生成的 pcap 文件就可以用 wireshark 打开进行更详细的分析了</p>
<p>也可以加上-U强制立即写到本地磁盘，性能稍差</p>
<h3 id="显示绝对的序号：-S-选项"><a href="#显示绝对的序号：-S-选项" class="headerlink" title="显示绝对的序号：-S 选项"></a>显示绝对的序号：-S 选项</h3><p>默认情况下，tcpdump 显示的是从 0 开始的相对序号。如果想查看真正的绝对序号，可以用 -S 选项。</p>
<p>没有 -S 时的输出，seq 和 ACK 都是从 0 开始</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any port 80 -nn</span><br></pre></td></tr></table></figure>
<p>没有 -S 时的输出，可以看到 seq 不是从 0 开始</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><p>tcpdump 真正强大的是可以用布尔运算符and（或&amp;&amp;）、or（或||）、not（或!）来组合出任意复杂的过滤器</p>
<p>抓取 ip 为 10.211.55.10 到端口 3306 的数据包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any host 10.211.55.10 and dst port 3306</span><br></pre></td></tr></table></figure>

<p>抓取源 ip 为 10.211.55.10，目标端口除了22 以外所有的流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10 and not dst port 22</span><br></pre></td></tr></table></figure>

<h3 id="复杂的分组"><a href="#复杂的分组" class="headerlink" title="复杂的分组"></a>复杂的分组</h3><p>如果要抓取：来源 ip 为 10.211.55.10 且目标端口为 3306 或 6379 的包，按照前面的描述，我们会写出下面的语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any src 10.211.55.10 and (dst port 3306 or 6379)</span><br></pre></td></tr></table></figure>
<p>如果运行一下，就会发现执行报错了，因为包含了特殊字符()，解决的办法是用单引号把复杂的组合条件包起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i any &#39;src 10.211.55.10 and (dst port 3306 or 6379)&#39;</span><br></pre></td></tr></table></figure>

<p>显示所有的 RST 包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump &#39;tcp[13] &amp; 4 !&#x3D; 0&#39;</span><br></pre></td></tr></table></figure>
<p>要弄懂这个语句，必须要清楚 TCP 首部中 offset 为 13 的字节的第 3 比特位就是 RST</p>
<p>下图是 TCP 头的结构</p>
<p><img src="https://raw.githubusercontent.com/zhanghaisong911/picBed/master/img/20200918001914.png" alt><br>tcp[13] 表示 tcp 头部中偏移量为 13 字节，如上图中红色框的部分，</p>
<p>!=0 表示当前 bit 置 1，即存在此标记位，跟 4 做与运算是因为 RST 在 TCP 的标记位的位置在第 3 位(00000100)</p>
<p>如果想过滤 SYN + ACK 包，那就是 SYN 和 ACK 包同时置位（00010010），写成 tcpdump 语句就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump &#39;tcp[13] &amp; 18 !&#x3D; 0&#39;</span><br></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>我们在机器 A（10.211.55.10）用nc -l 8080启动一个 tcp 的服务器，然后启动 tcpdump 抓包（sudo tcpdump -i any port 8080 -nn -A ）。然后在机器 B（10.211.55.5） 用 nc 10.211.55.10 8080进行连接，然后输入”hello, world”回车，过一段时间在机器 B 用 ctrl-c 结束连接，整个过程抓到的包如下（中间删掉了一些无关的信息）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 16:46:22.722865 IP 10.211.55.5.45424 &gt; 10.211.55.10.8080: Flags [S], seq 3782956689, win 29200, options [mss 1460,sackOK,TS val 463670960 ecr 0,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line">2 16:46:22.722903 IP 10.211.55.10.8080 &gt; 10.211.55.5.45424: Flags [S.], seq 3722022028, ack 3782956690, win 28960, options [mss 1460,sackOK,TS val 463298257 ecr 463670960,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line">3 16:46:22.723068 IP 10.211.55.5.45424 &gt; 10.211.55.10.8080: Flags [.], ack 1, win 229, options [nop,nop,TS val 463670960 ecr 463298257], length 0</span><br><span class="line"></span><br><span class="line">4 16:46:25.947217 IP 10.211.55.5.45424 &gt; 10.211.55.10.8080: Flags [P.], seq 1:13, ack 1, win 229, options [nop,nop,TS val 463674184 ecr 463298257], length 12</span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line">5 16:46:25.947261 IP 10.211.55.10.8080 &gt; 10.211.55.5.45424: Flags [.], ack 13, win 227, options [nop,nop,TS val 463301481 ecr 463674184], length 0</span><br><span class="line"></span><br><span class="line">6 16:46:28.011057 IP 10.211.55.5.45424 &gt; 10.211.55.10.8080: Flags [F.], seq 13, ack 1, win 229, options [nop,nop,TS val 463676248 ecr 463301481], length 0</span><br><span class="line"></span><br><span class="line">7 16:46:28.011153 IP 10.211.55.10.8080 &gt; 10.211.55.5.45424: Flags [F.], seq 1, ack 14, win 227, options [nop,nop,TS val 463303545 ecr 463676248], length 0</span><br><span class="line"></span><br><span class="line">8 16:46:28.011263 IP 10.211.55.5.45424 &gt; 10.211.55.10.8080: Flags [.], ack 2, win 229, options [nop,nop,TS val 463676248 ecr 463303545], length 0</span><br></pre></td></tr></table></figure>
<p>第 1~3 行是 TCP 的三次握手的过程</p>
<p>第 1 行 中，第一部分是这个包的时间（16:46:22.722865），显示到微秒级。接下来的 “10.211.55.5.45424 &gt; 10.211.55.10.8080” 表示 TCP 四元组：包的源地址、源端口、目标地址、目标端口，中间的大于号表示包的流向。接下来的 “Flags [S]” 表示 TCP 首部的 flags 字段，这里的 S 表示设置了 SYN 标志，其它可能的标志有</p>
<ul>
<li>F：FIN 标志</li>
<li>R：RST 标志</li>
<li>P：PSH 标志</li>
<li>U：URG 标志</li>
<li>. ：没有标志，ACK 情况下使用</li>
</ul>
<p>接下来的 “seq 3782956689” 是 SYN 包的序号。需要注意的是默认的显示方式是在 SYN 包里的显示真正的序号，在随后的段中，为了方便阅读，显示的序号都是相对序号。</p>
<p>接下来的 “win 29200” 表示自己声明的接收窗口的大小</p>
<p>接下来用[] 包起来的 options 表示 TCP 的选项值，里面有很多重要的信息，比如 MSS、window scale、SACK 等</p>
<p>最后面的 length 参数表示当前包的长度</p>
<p>第 2 行是一个 SYN+ACK 包，如前面所说，SYN 包中包序号用的是绝对序号，后面的 win = 28960 也声明的发送端的接收窗口大小。</p>
<p>从第 3 行开始，后面的包序号都用的是相对序号了。第三行是客户端 B 向服务端 A 发送的一个 ACK 包。注意这里 win=229，实际的窗口并不是 229，因为窗口缩放（window scale） 在三次握手中确定，后面的窗口大小都需要乘以 window scale 的值 2^7（128），比如这里的窗口大小等于 229 * 2^7 = 229 * 128 = 29312</p>
<p>第 4 行是客户端 B 向服务端 A 发送”hello world”字符串，这里的 flag 为P.,表示 PSH+ACK。发送包的 seq 为 1:13，长度 length 为 12。窗口大小还是 229 * 128</p>
<p>第 5 行是服务端 A 收到”hello world”字符串以后回复的 ACK 包，可以看到 ACK 的值为 13，表示序号为 13 之前的所有的包都已经收到，下次发包从 13 开始发</p>
<p>第 6 行是客户端 B 执行 Ctrl+C 以后nc 客户端准备退出时发送的四次挥手的第一个 FIN 包，包序号还是 13，长度为 0</p>
<p>第 7 行是服务端 A 对 B 发出的 FIN 包后，也同时回复 FIN + ACK，因为没有往客户端传输过数据包，所以这里的 SEQ 还是 1。</p>
<p>第 8 行是客户端 A 对 服务端 B 发出的 FIN 包回复的 ACK 包</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>对方怀疑我方有问题，查看对方这个ip下端口的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -i any -nn host 121.36.52.74 -s 0 -w dump &amp;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcpdump -r dump -nn | grep &#39;\[S\]&#39; | awk &#39;&#123;print $3&#125;&#39; | sort | uniq -c | sort -rn|less</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>redis源码之sds</title>
    <url>/2020/05/03/redis%E6%BA%90%E7%A0%81%E4%B9%8Bsds/</url>
    <content><![CDATA[<p>从开始工作就开始使用Redis，也有一段时间了，但都只是停留在使用阶段，没有往更深的角度探索，每次想读源码都止步在阅读书籍上，因为看完书很快又忘了，这次逼自己先读代码。因为个人觉得写作需要阅读文字来增强灵感，那么写代码的，就阅读更多代码来增强灵感吧。</p>
<p>redis的实现原理，在《Redis设计与实现》一书中讲得很详细了，但是想通过结合代码的形式再深入探索，加深自己的理解，以redis3.0做参考，现在将自己探索的心得写在这儿。</p>
<a id="more"></a>

<h2 id="sds-结构定义"><a href="#sds-结构定义" class="headerlink" title="sds 结构定义"></a>sds 结构定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="sds特性的实现"><a href="#sds特性的实现" class="headerlink" title="sds特性的实现"></a>sds特性的实现</h2><p>在Redis设计与实现一书中讲到，相比C字符串而言，sds的特性如下：</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少内存重新分配次数</li>
<li>二进制安全</li>
</ul>
<h3 id="数复杂度获取字符串长度"><a href="#数复杂度获取字符串长度" class="headerlink" title="数复杂度获取字符串长度"></a>数复杂度获取字符串长度</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*)(<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c语言获取字符串长度从头到尾是遍历 O(n), sds本身有记录长度len O(1)</p>
<p><img src="https://raw.githubusercontent.com/follyhs/picBed/master/img/sds.png" alt="sds"></p>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>对于C字符串的操作函数来说，如果在修改字符串的时候忘了为字符串分配足够的空间，就有可能出现缓冲区溢出的情况。而sds中的API就不会出现这种情况，因为它在修改sds之前，都会判断它是否有足够的空间完成接下来的操作。</p>
<p>拿书中举例的<code>sdscat</code>函数来看，如果<code>strcat</code>想在原来的”Redis”字符串的基础上进行字符串拼接的操作，但是没有检查空间是否满足，就有可能会修改了”Redis”字符串之后使用到的内存，可能是其他结构使用了，也有可能是一段没有被使用的空间，因此有可能会出现缓冲区溢出。但是<code>sdscat</code>就不会，如下面代码所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span> </span>&#123;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span>   </span><br><span class="line">    <span class="comment">// 原有字符串长度</span></span><br><span class="line">    <span class="keyword">size_t</span> curlen = sdslen(s);</span><br><span class="line">    <span class="comment">// 扩展 sds 空间</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="comment">// 内存不足？直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 复制 t 中的内容到字符串后部</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    <span class="comment">// 添加新结尾符号</span></span><br><span class="line">    s[curlen+len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 返回新 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，在执行<code>memcpy</code>将字符串写入sds之前会调用<code>sdsMakeRoomFor</code>函数去检查sds字符串s是否有足够的空间，如果没有足够空间，就为其分配足够的空间，从而杜绝了缓冲区溢出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T = O(N)</span></span><br><span class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="comment">// 获取 s 目前的空余空间长度</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="keyword">size_t</span> len, newlen;</span><br><span class="line">    <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="comment">// 获取 s 目前已占用空间的长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (<span class="keyword">void</span>*) (s-(<span class="keyword">sizeof</span>(struct sdshdr)));</span><br><span class="line">    <span class="comment">// s 最少需要的长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC </span></span><br><span class="line">        <span class="comment">// 那么为它分配两倍于所需长度的空间</span></span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 内存不足，分配失败，返回</span></span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 更新 sds 的空余长度</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="comment">// 返回 sds</span></span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="减少内存分配操作"><a href="#减少内存分配操作" class="headerlink" title="减少内存分配操作"></a>减少内存分配操作</h3><p>在程序中很多对字符串的操作都的修改字符串内容，如果每次都是分配刚刚好的大小，那么每一个人动作都要申请和释放内存，势必会对程序的性能有影响，因为内存非配涉及到系统调用及一些复杂的算法。sds采用空间与分配和惰性释放的策略来减少对内存的操作。</p>
<p>上面说到的每次修改字符串都要调用<code>sdsMakeRoomFor</code> 检查sds字符串，如果空间不够才会重新分配，分配策略是如果长度小于1M，则分配原来的2倍，否则新增1MB的空间。</p>
<p>如果操作后减少了字符串，比如下面的函数，只是在最后修改len属性，不会马上释放空间，而是继续保留，下次需要增加的时候不需要为其分配空间了，当然如果sds太大也会调用sdsRemoveFreeSpace释放掉多余的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdstrim</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *cset)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span>*) (<span class="title">s</span>-(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></span><br><span class="line">    <span class="keyword">char</span> *start, *<span class="built_in">end</span>, *sp, *ep;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="comment">// 设置和记录指针</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = <span class="built_in">end</span> = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 修剪, T = O(N^2)</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= <span class="built_in">end</span> &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;</span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;</span><br><span class="line">    <span class="comment">// 计算 trim 完毕之后剩余的字符串长度</span></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 如果有需要，前移字符串内容</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);</span><br><span class="line">    <span class="comment">// 添加终结符</span></span><br><span class="line">    sh-&gt;buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">// 更新属性</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">// 返回修剪后的 sds</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>c语言的字符串中间是不允许出现空字符的，只能出现在末尾用于标示结束，像音频，视频，压缩文件这样的二进制中是会出现空字符的，所以不能用c字符串来保存。sds使用的是len属性值而不是空字符串来判断结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文笔有限，才疏学浅，不正之处，万望告知。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis源码</tag>
      </tags>
  </entry>
</search>
